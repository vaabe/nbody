---
title: 'numerical integration \& validation'
output:
  tufte::tufte_html:
    tufte_features: ['fonts','background','italics']
    css: 'tufte.css'
  tufte::tufte_handout:
    citation_package: natbib
    latex_engine: xelatex
  tufte::tufte_book:
    citation_package: natbib
link-citations: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(gridExtra)
library(ggpmisc)
library(plotly)
library(latex2exp)
library(reticulate)
library(tufte)
```

\renewcommand{\v}[1]{{\boldsymbol #1}}
\renewcommand{\dv}[1]{\dot{\boldsymbol{#1}}}
\newcommand{\ddv}[1]{\ddot{\boldsymbol{#1}}}
\newcommand{\hv}[1]{\hat{\boldsymbol{#1}}}
\newcommand{\m}[1]{[ #1 ]}
\renewcommand{\t}[1]{\widetilde{\boldsymbol{#1}}}
\newcommand{\bfit}[1]{\textbf{\textit{#1}}}

\renewcommand{\d}{\text{d}}
\renewcommand{\dd}[2]{\frac{\d #1}{\d #2}}
\newcommand{\ddd}[2]{\frac{\d^2 #1}{\d #2^2}}
\newcommand{\ddt}[1]{\frac{\d #1}{\d t}}
\newcommand{\dddt}[1]{\frac{\d^2 #1}{\d t^2}}
\newcommand{\pd}[2]{\frac{\partial #1}{\partial #2}}
\newcommand{\pdd}[2]{\frac{\partial^2 #1}{\partial #2^2}}
\renewcommand{\grad}{\boldsymbol \nabla} 
\renewcommand{\div}{\boldsymbol \nabla \cdot}
\renewcommand{\curl}{\boldsymbol \nabla \times}
\newcommand{\lap}{\nabla^2}
\newcommand{\intinf}{\int_{-\infty}^\infty}
\newcommand{\intzinf}{\int_0^\infty}
\newcommand{\intinfz}{\int_{-\infty}^0}

\newcommand{\eo}{\epsilon_0}
\newcommand{\muo}{\mu_0}

Numerical methods are generally required to solve the $n$-body problem due to the chaotic nature of the solution when $n \geq 3$. The most common method is using an integrator, since the equations of motion are second order ODEs that must be integrated to give the positions of the bodies. Presented in this section are a few different integrators for the $n$-body problem using Verlet, Runge-Kutta, and Hermite methods. 

Linked <a href="https://github.com/vaabe/nbody/verlet">_here_</a> are a few integrators written in C++.  

\ 

## setup 

In Cartesian coordinates, $\v r = \v r(x,y,z)$, and there are three second order ODEs that must be integrated for each body:

$$
\ddv r = \sum_{i, i \neq j}^n \frac{G m_j}{r_{ij}^3} (\v r_j - \v r_i) = 
\begin{cases}
	\ddot x = \sum_{i, i \neq j}^n \frac{G m_j}{r_{ij}^3} (x_j - x_i) \\ 
	\ddot y = \sum_{i, i \neq j}^n \frac{G m_j}{r_{ij}^3} (y_j - y_i) \tag{1} \\ 
	\ddot z = \sum_{i, i \neq j}^n \frac{G m_j}{r_{ij}^3} (z_j - z_i) \\ 
\end{cases}
$$

For n bodies there are a total of 3n second order ODEs for the whole problem. Most integrators involve transforming these equations into 6n first order equations, by defining a velocity variable $\v v$: 

$$\dv r = \v v \tag{2}$$

where $\v v = \v v(v_x, v_y, v_z)$. Equation (1) can then be written as a first order equation in the form $\dv v = f(\v r, t)$ and the solution for $\v v(t)$ can be recombined to get $\v r(t)$.  

In the sections below, various integrators are validated by testing them on the two-body problem and comparing the numerical solutions to the known analytic solution. 

\ 

## verlet integration 

Verlet integration involves computing the positions at each time step by extrapolating from the velocity at the previous half time step. The following equations are repeatedly applied to obtain the positions at subsequent time steps:

$$\v v(t + \tfrac 12 \d t) = \v v(t) + \tfrac 12 \v a(t) \d t$$

$$\v r(t + \d t) = \v r(t) + \v v(t + \tfrac 12 \d t) \d t$$

Verlet integration is time-reversal symmetric and provides numeric solutions that are stable in the long run. For this reason the Verlet method is often favourable compared to more precise methods such as Runge-Kutta and Hermite integration, as the latter do not guarantee long-run stability as consistently.  

\ 

## testing the orbital period 

Using rescaled variables with $G=1$, $m_1 = 0.999$, $m_2 = 0.001$, and the following initial positions and velocities:

$$
m_1 = 
\begin{cases}
	{x_0 = 0, y_0 = 0} \\ 
	{vx_0 = 0, vy_0 = 0}
\end{cases}	
$$

$$
m_2 = 
\begin{cases}
	{x_0 = 1, y_0 = 0} \\ 
	{vx_0 = 0, vy_0 = 0.7}
\end{cases}	
$$

Below is a closed form render of the trajectories:

`insert gif` 

```{r, echo=F, warning=F, message=F}
alldata = read.csv("./data/posdata_kepler_N_2_G_1_t0_0_tf_20_dt_0.01.csv") %>%
  select(-X)
 
N = 2
G = 1
t0 = 0
tf = 20
dt = 0.01
TN = (tf-t0)/dt
m1 = 0.999
m2 = 0.001

x_alldata = alldata[ ,1:N]
y_alldata = alldata[ ,(N+1):(2*N)]
z_alldata = alldata[ ,(2*N+1):(3*N)]

x_alldata = x_alldata %>%
  gather(coord,x)
y_alldata = y_alldata %>%
  gather(coord,y) 
z_alldata = z_alldata %>%
  gather(coord,z) 

bodylabels = NULL
for (i in 1:N) {
  bodylabels[i] = paste("m",i,sep = "")
}

bodylabels_list = NULL

for (i in 1:N) {
  bodylabels_list = append(bodylabels_list, rep(bodylabels[i],TN))
}

## vertical dataset
vertdata = data.frame(x = x_alldata$x, 
			  y = y_alldata$y, 
			  z = z_alldata$z, 
			  body = bodylabels_list,
			  t = c(rep(alldata$t,N)))

df = alldata

df = df %>%
  mutate(r1 = x1**2 + y1**2 + z1**2, 
         r2 = x2**2 + y2**2 + z2**2, 
         rCoM = (m1*r1 + m2*r2)/(m1+m2), 
         r1CoM = abs(r1 - rCoM), 
         r2CoM = abs(r2 - rCoM))

# get perihelion and aphelion positions
perihelion = min(df$r2 - df$r1)
peri_index = which.min(df$r2 - df$r1)

aphelion = max(df$r2 - df$r1)
aph_index = which.max(df$r2 - df$r1)
```

Below is a plot of $r$ on $t$:

\ 

```{r, echo=F, out.height=350, out.width=500, fig.align='center'}
ggplot(data = df, aes(x = t, y = r2CoM)) +
  geom_line() +
  stat_peaks(geom = 'text', colour = 'black', strict = FALSE,
             vjust = -0.5, x.label.fmt = '%.4f', check_overlap = TRUE, size = 3) +
  xlab('t') + ylab('r') + 
  theme_linedraw() +  
  theme(panel.background = element_rect(fill = '#f3dbda', colour = '#f3dbda')) +
  theme(plot.background = element_rect(fill = '#f3dbda', color = '#f3dbda')) 
```

\ 

The numerical period is: 

```{r}
tau = 6.77-3.39
tau
```

The analytic solution gives the period as follows:

$$\tau = \sqrt{\frac{4\pi^2 a^2}{G(m_1 + m_2)}}$$

where $a$ is the semimajor (the distance from the aphelion/perihelion to the origin).   


```{r}
a = abs((df$x2[aph_index] - df$x2[peri_index])/2)
period = sqrt((4 * pi**2 * a**3)/(G*(m1+m2)))
period
```

Consistent.  

\ 

